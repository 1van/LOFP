# ![LOFP](lofp.jpg)

## Novice

Concepts | Skills
-------- | --------
Immutable Data | Use second-order functions (mop, filter. fold) on immutable data structures
Second-Order Functions | Destructure values to access their components
Constructing S. Destructuring | Use data types to represent optionality
Function Composition | Read basic type signatures
First-Class Functions & Lambdas | Pass lambdas to second-order functions

## Advanced Beginner

Concepts | Skills
-------- | --------
Algebraic Data Types | Solve problems without nulls, exceptions. or type casts
Pattern Matching | Process & transform recursive data structures using recursion
Parametric Polymorphism | Able to use functional programming 'in the small'
General Recursion | Write basic monadic code for a concrete monad
Type Classes, Instances, & Laws | Create type class instances for custom data types
Lower-Order Abstractions (Equal. Semigroup, Mold. etc) | Model a business domain with ADTs
Referential Transparency & Totality | Write functions that take and return functions
Higher-Order Functions | Reliably identify & isolate pure code from impure code
Partial-Application. Currying. & Point-Free Style | Avoid introducing unnecessary lambdas & named parameters

## Competent

Concepts | Skills
-------- | --------
Generalized Algebraic Data Types | Able to use functional programming 'in the large'
Higher-Kinded Types | Test code using generators and properties
Rank-N Types | Write imperative code in a purely functional way through monads
Folds & Unfolds | Use popular purely functional libraries to solve business problems
Higher-Order Abstractions (Category, Functor. Monad) | Separate decision from effects
Basic Optics | Write a simple custom lawful monad
Efficient Persistent Data Structures | Write production medium-sized projects
Existential Types | Use lenses & prisms to manipulate data
Embedded DSLs using Combinatory | Simplify types by hiding irrelevant data with existentiols

## Proficient

Concepts | Skills
-------- | --------
Codoto | Design a minimolly-powerful monad transformer stack
(Co)Recursion Schemes | Write concurrent and streaming programs
Advanced Optics | Use purely functional mocking in tests
Dual Abstractions (Comonad) | Use type classes to modularly model different effects
Monad Transformers | Recognize type patterns 8. abstract over them
Free Monads & Extensible Effects | Use functional libraries in novel ways
Functional Architecture | Use optics to manipulate state
Advanced Functors (Exponential. P(ofunctors, Contravariant) | Write custom lawful monad transformers
Embedded DSLs using GADTs. Finally Togless | Use free monads / extensible effects to separate concerns
Advanced Monads (Continuation. Logic) | Encode invariants at the type level
Type Families, Functional Dependencies | Effectively use FDs / type families to create safer code

## Expert

Concepts | Skills
-------- | --------
High-Performance | Design a generic, lawful library with broad appeal
Kind Polymorphism | Prove properties manually using equational reasoning
Generic Programming | Design & implement a new functional programming language
Type-Level Programming | Create novel abstractions with laws
Dependent-Types. Singleton Types | Write distributed systems with certain guarantees
Category Theory | Use proof systems to formally prove properties of code
Graph Reduction | Create libraries that do not permit invalid states
Higher-Order Abstract Syntax | Use dependent-typing to prove more properties at compile-time
Compiler Design for Functional Languages | Understand deep relationships between different concepts
Profunctor Optics | Profile. debug, & optimize purely functional code with minimal sacrifices
